/*
Реализуй класс SortingUtil, который будет содержать публичные статические методы, необходимые для сортировки значений массивов. Класс должен удовлетворять следующим требованиям:

1. В классе должен быть реализован публичный статичный свободный метод sortInts, который принимает в качестве параметров массив целых чисел типа int. Метод должен выполнять сортировку массива по возрастанию. Алгоритм сортировки может быть любым.
2. В классе должен быть реализован публичный статичный свободный метод sortDoubles, который принимает в качестве параметров массив элементов класса-обертки Double. Метод должен выполнять сортировку массива по возрастанию. Алгоритм сортировки может быть любым. Все элементы null должны перемещаться в конец массива.
3. Для обоих методов, в случае если в качестве параметра передан пустой массив или не инициализированный массив, на экран должно выводиться сообщение: “Empty data”
*/

public class SortingUtil {
	public static void sortInts(int[] s) {
		if (s == null) { //проверка на null
			System.out.println("Empty Data");
		} else if (s.length == 0) { // проверка на наличие элементов
			System.out.println("Empty Data");
		} else {
			int max; //хранилище для чисел
			for(int i = 1; i < s.length; ++i) { //пробегаем массив
				for(int j = 0; j < s.length - i; ++j) { //пробегаем для сравнения
					if (s[j] > s[j + 1]) { //ищем максимум
						max = s[j];
						s[j] = s[j + 1]; //меняем местами соседние числа
						s[j + 1] = max; //новый максимум чисел
					}
				}
			}
		}
	}
	public static void sortDoubles(Double[] s) {
		if (s == null) { //проверка на null
			System.out.println("Empty Data");
		} else if (s.length == 0) { // проверка на наличие элементов
			System.out.println("Empty Data");
		} else {
			int n = 0;
			Double max; //хранилище для чисел
			for(int i = 1; i < s.length - n; ++i) { //пробегаем массив
				for(int j = 0; j < s.length - i; ++j) { //пробегаем для сравнения
					if (s[j] != null && s[j + 1] != null) { //проверка на null в пузыре
						if (s[j] > s[j + 1]) { //ищем максимум
							max = s[j];
							s[j] = s[j + 1]; //меняем местами соседние числа
							s[j + 1] = max; //новый максимум чисел
						}
					} else if (s[j] == null && j != s.length - 1) { //проверка на null в конце
						s[j] = s[j + 1];
						s[j + 1] = null;
					} else if (s[j + 1] == null && j + 1 != s.length - 1) { //проверка на null в конце
						s[j + 1] = s[j + 2];
						s[j + 2] = null;
					}
				}
			}
		}
	}
}