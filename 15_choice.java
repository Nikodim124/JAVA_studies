/*
Задача, поставленная разработчику, звучит следующим образом:

Компания PineApple анализирует продажи подразделений, расположенных в разных странах, на определенную дату. Аналитикам компании необходима возможность отсортировать подразделения по возрастанию объемов продаж.

Необходимо в приложение добавить статический метод sortSales, который не возвращает значение, но сортирует данные о продажах. В метод sortSales должны передаваться два массива данных:

Массив названий стран подразделений (строки);
Массив данных о продажах (действительные числа).
Данные, которые будут передаваться в метод, по умолчанию синхронизированы (0-й элемент массива данных о продажах соответствует 0-му элементу массива стран, 1-й - 1-му и т.д.).

Необходимо реализовать следующую логику работы метода:

Если в метод были переданы поврежденные данные (размеры массивов не соответствуют друг другу), необходимо вывести на консоль сообщение "Corrupted Data" и не выполнять сортировки;
Если в метод  были переданы пустые массивы, необходимо вывести на консоль сообщение "Empty Data" и не выполнять сортировки;
Во всех остальных случаях необходимо выполнить сортировку обоих массивов с учетом следующих требований:
необходимо использовать двунаправленный алгоритм сортировки выбором, в котором за один проход одновременно находятся и переставляются максимальный элемент (в конец неотсортированной части массива) и минимальный элемент (в начало неотсортированной части массива);
сортировку необходимо провести синхронно, т. е. если осуществляется перестановка значений в массиве данных о продажах, должна осуществляться аналогичная (по индексам) перестановка в массиве названий стран;
после каждой двунаправленной перестановки необходимо выводить на консоль все содержимое обоих массивов с помощью метода printData (см. примечания);
после завершения сортировки необходимо вывести на консоль все содержимое обоих массивов с помощью метода printData.

Приведи фрагмент кода, который определяет публичный статичный метод sortSales в соответствии с приведенным описанием задачи.
*/

public static void sortSales(String[] c, double[] s) {
	if (s.length != c.length) { //проверка на равность массивов
		System.out.println("Corrupted Data");
	} else if (s.length == 0 && c.length == 0) { //проверка на наличие элементов
		System.out.println("Empty Data");
	} else {
		double tmp; //контейнер для чисел
		String temp; //контейнер для строк
		int n = s.length-1;
		for(int i = 0; i <= n; i++) { //пробегаем
			double max = s[i]; //принимаем первый элемент за min и max
			double min = s[i];
			int max_index = i; //так же с индексами
			int min_index = i;
			for(int j=i+1; j<=n; j++) { //сравниваем
				if(s[j]>max) {
					max=s[j];
					max_index=j;
				}
				if(s[j]<min) {
					min=s[j];
					min_index=j;
				}
			}
			if(max_index==i && min_index!=n) { //если максимум стоит в начале, а минимум в центре
				tmp = s[n];
				temp = c[n];
				s[n] = s[max_index];
				c[n] = c[max_index];
				s[max_index] = tmp;
				c[max_index] = temp;
				tmp = s[i];
				temp = c[i];
				s[i] = s[min_index];
				c[i] = c[min_index];
				s[min_index] = tmp;
				c[min_index] = temp;
			}
			if(min_index==n && max_index!=i) { //если минимум стоит в конце, а максимум в центре
				tmp = s[i];
				temp = c[i];
				s[i] = s[min_index];
				c[i] = c[min_index];
				s[min_index] = tmp;
				c[min_index] = temp;
				tmp = s[n];
				temp = c[n];
				s[n] = s[max_index];
				c[n] = c[max_index];
				s[max_index] = tmp;
				c[max_index] = temp;
			}
			if(min_index==n && max_index==i) { //если искомые элементы находятся на противоположных концах
				tmp = s[n];
				temp = c[n];
				s[n] = s[i];
				c[n] = c[i];
				s[i] = tmp;
				c[i] = temp;
			}
			if(min_index!=n && max_index!=i) { //если оба искомыъх элемента в центре
				tmp = s[n];
				temp = c[n];
				s[n] = s[max_index];
				c[n] = c[max_index];
				s[max_index] = tmp;
				c[max_index] = temp;
				tmp = s[i];
				temp = c[i];
				s[i] = s[min_index];
				c[i] = c[min_index];
				s[min_index] = tmp;
				c[min_index] = temp;
			}
			n--; //сокращаем границу цикла
			printData(c, s); //печатаем промежуточный итог
		}
	printData(c, s); //окончательный вывод
	}
}

private static void printData(String[] names, double[] data) {
    System.out.print("{");
    for (int i=0; ilength;i++){
        System.out.print(names[i]+": "+data[i]+", ");
    }
    System.out.println("\b\b}");
}