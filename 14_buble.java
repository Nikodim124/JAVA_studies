/*
Задача, поставленная разработчику, звучит следующим образом:

Компания PineApple анализирует продажи подразделений, расположенных в разных странах, на определенную дату. Аналитикам компании необходима возможность отсортировать подразделения по убыванию объемов продаж.

Необходимо в приложение добавить статический метод sortSales, который не возвращает значение, но сортирует данные о продажах. В метод sortSales должны передаваться два массива данных:

Массив названий стран подразделений (строки);
Массив данных о продажах (действительные числа).
Данные, которые будут передаваться в метод, по умолчанию синхронизированы (0-й элемент массива данных о продажах соответствует 0-му элементу массива стран, 1-й – 1-му и т. д.).

Необходимо реализовать следующую логику работы метода:

Если в метод были переданы поврежденные данные (размеры массивов не соответствуют друг другу), необходимо вывести на консоль сообщение "Corrupted Data" и не выполнять сортировки;
Если в метод были переданы пустые массивы, необходимо вывести на консоль сообщение "Empty Data" и не выполнять сортировки;
Во всех остальных случаях необходимо выполнить сортировку обоих массивов,с учетом следующих требований:
необходимо использовать алгоритм сортировки пузырьком;
сортировку необходимо провести синхронно, т. е. если осуществляется перестановка значений в массиве данных о продажах, должна осуществляться аналогичная (по индексам) перестановка в массиве названий стран;
после каждой перестановки необходимо выводить на консоль все содержимое обоих массивов с помощью метода printData (см. примечания);
после завершения сортировки необходимо вывести на консоль все содержимое обоих массивов с помощью метода printData.

Приведи фрагмент кода, который определяет публичный статичный метод sortSales в соответствии с приведенным описанием задачи.
*/

public static void sortSales(String[] c, double[] s) {
	if (s.length != c.length) { //проверка на равность массивов
		System.out.println("Corrupted Data");
	} else if (s.length == 0 && c.length == 0) { //проверка на наличие элементов
		System.out.println("Empty Data");
	} else {
		double max1; //хранилище для чисел
		String max2; //хранилище для строк
		for(int i = 1; i < s.length; ++i) { //пробегаем массив
			for(int j = 0; j < s.length - i; ++j) { //пробегаем для сравнения
				if (s[j] < s[j + 1]) { //ищем максимум
					max1 = s[j];
					max2 = c[j];
					s[j] = s[j + 1]; //меняем местами соседние числа
					c[j] = c[j + 1]; //меняем местами соседние строки
					s[j + 1] = max1; //новый максимум чисел
					c[j + 1] = max2; //новый максимум для строк
					printData(c, s); //вывод
				}
			}
		}
	printData(c, s); //вывод окончательного массива
	}
}

private static void printData(String[] names, double[] data) {
    System.out.print("{");
    for (int i=0; ilength;i++){
        System.out.print(names[i]+": "+data[i]+", ");
    }
    System.out.println("\b\b}");
}