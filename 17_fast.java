/*
Задача, поставленная разработчику, звучит следующим образом:

Системный аналитик проанализировал метод сортировки sortSales, использованный для сортировки данных о продажах компании PineApple, 
и сформулировал новое системное требование.

Необходимо переписать метод sortSales таким образом, чтобы его производительность не зависела от количества анализируемых данных в диапазоне от 1 до 40000 элементов.

Таким образом, требования к методу sortSales сформулированы следующим образом:

Метод должен сортировать данные по возрастанию объемов продаж.
Метод должен принимать массив строк, содержащих наименование/идентификатор анализируемой бизнес-единицы (это может быть как страна, так и отдельный магазин) 
в качестве первого параметра.
Метод должен принимать массив double, содержащий значение объема продаж для соответствующей бизнес-единицы, в качестве второго параметра.
Данные, которые будут передаваться в метод, по умолчанию синхронизированы 
(0-й элемент массива данных о продажах соответствует 0-му элементу массива бизнес-единиц, 1-й – 1-му и т.д.).
Если в метод были переданы поврежденные данные (размеры массивов не соответствуют друг другу), 
необходимо вывести на консоль сообщение "Corrupted Data" и не выполнять сортировки.
Если в метод были переданы пустые массивы, необходимо вывести на консоль сообщение "Empty Data" и не выполнять сортировки.
Во всех остальных случаях необходимо выполнить сортировку обоих массивов с учетом следующих требований:
	-алгоритм сортировки должен выполняться полностью не дольше 0,2 секунд;
	-сортировка должна происходить синхронно, т. е. если осуществляется перестановка значений в массиве данных о продажах, 
	должна осуществляться аналогичная (по индексам) перестановка в массиве названий/идентификаторов бизнес-единиц;
	-вывод массивов на консоль должен осуществляться с помощью метода printData только 1 раз – после завершения сортировки.


Приведи фрагмент кода, который определяет публичный статичный метод sortSales в соответствии с приведенным описанием задачи.
*/

public static void sortSales(String[] c, double[] s) {
	if (s.length != c.length) { //проверка на равность массивов
		System.out.println("Corrupted Data");
	} else if (s.length == 0 && c.length == 0) { //проверка на наличие элементов
		System.out.println("Empty Data");
	} else {
		for (int i = s.length / 2; i >= 1; i = i / 2) {
			for (int j = 0; j < i; j++) {
				insertionSort (c, s, j, i);
			}
		}
	printData(c, s);
	}
}

private static void insertionSort(String[] c, double[] s, int start, int k){
	double tmp;
	String temp;
	for (int i = start; i < s.length - 1; i += k) {
		for (int j = Math.min(i+k, s.length-1); j-k >= 0; j = j-k) {
			if (s[j - k] > s[j]) {
				tmp = s[j];
				temp = c[j];
				s[j] = s[j-k];
				c[j] = c[j-k];
				s[j-k] = tmp;
				c[j-k] = temp;
			} else {
				break;
			}
		}
	}
}

private static void printData(String[] names, double[] data) {
    System.out.print("{");
    for (int i=0; i<data.length;i++){
        System.out.print(names[i]+": "+data[i]+", ");
    }
    System.out.println("\b\b}");
}
